
<!-- index.html -->
{% extends 'layout.html' %}

{% block title %}Home Page{% endblock %}

{% block content %}
    <div>
        <canvas id="myChart"></canvas>
    </div>


    <h4>Average</h4>
    <table>
        <tr>
            <th>Key</th>
            <th>Value</th>
        </tr>
        {% for key, value in analysis_data.items() %}
            <tr>
                <td>{{ key }}</td>
                <td>{{ value }}</td>
            </tr>
        {% endfor %}
    </table>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script>



    // Flask에서 전달한 데이터를 파싱
    var chartData = {{ chart_data | safe }};




    var colorRed = 'rgba(255, 0, 0, 1)'
    var colorBlue = 'rgba(0, 0, 255, 1)'
    var colorData = 'rgba(75, 192, 192, 0.2)'
    var colorBlack = 'rgba(0, 0, 0, 1)'



    var legends = [
        {
            color:  colorData,
            label: 'Data'
        },
        {
            color:  colorRed,
            label: 'Limit Up'
        },
        {
            color:  colorBlue,
            label: 'Limit Down'
        },
    ];





    var canvas = document.getElementById('myChart');


    canvas.height = 300;

    const minY = {{minY}} - 10
    const maxY = {{maxY}} + 10
    // const minY = Math.min(...chartData.values, ...limitData.up, ...limitData.down) - 10;
    // const maxY = Math.max(...chartData.values, ...limitData.up, ...limitData.down) + 10;
    // 차트 생성

    var ctx = document.getElementById('myChart').getContext('2d');
    var myChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [
            {
                label: 'Data',
                data: chartData.map( item => ({y: item.value, x:item.datetime})), 
                backgroundColor: function(context) {
                // Check if the point is outside the Upper or Lower Limit
                    const index = context.dataIndex;
                    const value = chartData[index].value;
                    const limitUp = chartData[index].limit_up;
                    const limitDown = chartData[index].limit_down;

                    if (value > limitUp || value < limitDown) {
                        return colorRed; // Red color for points outside limits
                    } else {
                        return colorData;
                    }
                },
                borderColor: colorBlack,
                borderWidth: 1,
                pointRadius: 3,  // 점의 크기를 조절
                type:'scatter'
            },
            {
                label: 'Upper Limit',
                data: chartData.map( item => ({y: item.limit_up, x:item.datetime})), 
                borderColor: legends[1].color,
                borderWidth: 1,
                fill: false,
                type: 'line',  // Line 데이터 타입 설정
                pointRadius: 0
            },
            {
                label: 'Lower Limit',
                data: chartData.map( item => ({y: item.limit_down, x:item.datetime})), 
                borderColor: legends[2].color,
                borderWidth: 1,
                fill: false,
                type: 'line',
                pointRadius: 0
            }
        ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,

            animation: {
            duration: 0, // Set duration to 0 to disable animations
            },  
            scales: {
                x: {
                    type: 'time',
                    time: {
                        unit: 'month',
                        parser: 'yyyy-MM-dd',
                        },
                    position: 'bottom',
                    stepSize: 2,
                    
                },
                y: {
                    beginAtZero: false,
                    min: minY,
                    max: maxY,
                    
                },
                
            },
            plugins: {            
                legend: {
                display: true,
                    labels: {
                        fontcolor: 'rgb(255, 99, 132)',
                        fontsize: 22,
                        generateLabels: function (chart) {
                            return legends.map(function (color, index) {
                                return {
                                    text: legends[index].label,
                                    fillStyle: legends[index].color,
                                    strokeStyle:'rgba(0, 0, 0, 1)',
                                };
                            });
                        }
                    }
                },
            }
        }
    });

</script>

{% endblock %}